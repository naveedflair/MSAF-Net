# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDV1EceVBQpoacWnWM3LKJkYH9Rq5Qwz
"""

import os
import numpy as np
import torch
from torch.utils.data import Dataset
import cv2
import pydicom

class CHAOSDataset(Dataset):
    def __init__(self, base_dir, transform=None):
        self.base_dir = base_dir
        self.transform = transform
        self.image_mask_pairs = self._get_image_mask_pairs()

    def _get_image_mask_pairs(self):
        pairs = []
        ct_count = 0
        mr_count = 0
        modalities = ['CT', 'MR']

        for modality in modalities:
            modality_dir = os.path.join(self.base_dir, 'Train_Sets', modality)
            if not os.path.exists(modality_dir):
                print(f"Directory not found: {modality_dir}")
                continue

            patient_dirs = [d for d in os.listdir(modality_dir) if os.path.isdir(os.path.join(modality_dir, d))]

            for patient_dir in patient_dirs:
                patient_path = os.path.join(modality_dir, patient_dir)

                if modality == 'MR':
                    for subdir in os.listdir(patient_path):
                        subdir_path = os.path.join(patient_path, subdir)
                        dicom_dir = os.path.join(subdir_path, 'DICOM_anon')

                        if not os.path.exists(dicom_dir):
                            continue

                        for phase in os.listdir(dicom_dir):
                            phase_path = os.path.join(dicom_dir, phase)

                            if not os.path.isdir(phase_path):
                                continue

                            image_files = sorted([f for f in os.listdir(phase_path) if f.endswith('.dcm')])
                            mask_dir = os.path.join(subdir_path, 'Ground')

                            if not os.path.exists(mask_dir):
                                continue

                            mask_files = sorted([f for f in os.listdir(mask_dir) if f.endswith('.png')])

                            if len(image_files) != len(mask_files):
                                continue

                            for img_file, mask_file in zip(image_files, mask_files):
                                pairs.append((
                                    os.path.join(phase_path, img_file),
                                    os.path.join(mask_dir, mask_file),
                                    modality
                                ))
                                mr_count += 1

                else:  # CT modality
                    dicom_dir = os.path.join(patient_path, 'DICOM_anon')

                    if not os.path.exists(dicom_dir):
                        continue

                    image_files = sorted([f for f in os.listdir(dicom_dir) if f.endswith('.dcm')])
                    mask_dir = os.path.join(patient_path, 'Ground')

                    if not os.path.exists(mask_dir):
                        continue

                    mask_files = sorted([f for f in os.listdir(mask_dir) if f.endswith('.png')])

                    if len(image_files) != len(mask_files):
                        continue

                    for img_file, mask_file in zip(image_files, mask_files):
                        pairs.append((
                            os.path.join(dicom_dir, img_file),
                            os.path.join(mask_dir, mask_file),
                            modality
                        ))
                        ct_count += 1

        print(f"Total pairs found: {len(pairs)}")
        print(f"Total CT pairs: {ct_count}")
        print(f"Total MR pairs: {mr_count}")

        return pairs

    def __len__(self):
        return len(self.image_mask_pairs)

    def __getitem__(self, idx):
        img_path, mask_path, modality = self.image_mask_pairs[idx]

        # Load DICOM image
        image = pydicom.dcmread(img_path).pixel_array

        # Normalize based on modality
        if modality == 'CT':
            image = self._normalize_ct(image)
        else:  # MR
            image = self._normalize_mr(image)

        # Load mask
        mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)

        # Resize images to 224x224
        image = cv2.resize(image, (224, 224), interpolation=cv2.INTER_LINEAR)
        mask = cv2.resize(mask, (224, 224), interpolation=cv2.INTER_NEAREST)

        # Convert mask to binary
        mask = (mask > 0).astype(np.float32)

        # Add channel dimension
        image = np.expand_dims(image, axis=0)
        mask = np.expand_dims(mask, axis=0)

        # Convert to PyTorch tensors
        image = torch.from_numpy(image).float()
        mask = torch.from_numpy(mask).float()

        if self.transform:
            image = self.transform(image)

        return image, mask

    def _normalize_ct(self, image):
        image = np.clip(image, -1024, 1024)
        image = (image + 1024) / 2048
        return image.astype(np.float32)

    def _normalize_mr(self, image):
        min_val = np.min(image)
        max_val = np.max(image)

        if max_val - min_val > 0:
            image = (image - min_val) / (max_val - min_val)

        return image.astype(np.float32)