# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDV1EceVBQpoacWnWM3LKJkYH9Rq5Qwz
"""

import torch
from torchvision import models
from torch.optim.lr_scheduler import ReduceLROnPlateau

from config import *
from data.dataset import CHAOSDataset
from models.msaf_net import MSAF_Net
from models.losses import BoundaryAwareLoss
from training.trainer import Trainer
from training.metrics import dice_coefficient, iou_score
from visualization.plots import plot_training_curves, save_and_plot_predictions_fixed
from utils.helpers import get_data_loaders, get_fixed_test_images

def main():
    # Initialize dataset
    dataset = CHAOSDataset(base_dir=BASE_DIR, transform=data_transform)

    # Get data loaders
    train_loader, val_loader, test_loader = get_data_loaders(
        dataset, BATCH_SIZE, TRAIN_RATIO, VAL_RATIO, TEST_RATIO
    )

    # Initialize model
    backbone = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V1)
    model = MSAF_Net(backbone).to(device)

    # Initialize loss, optimizer, and scheduler
    criterion = BoundaryAwareLoss(dice_weight=DICE_WEIGHT, boundary_weight=BOUNDARY_WEIGHT)
    optimizer = torch.optim.Adam(model.parameters(), lr=LEARNING_RATE, weight_decay=WEIGHT_DECAY)
    scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=0.1, patience=5, verbose=True)

    # Initialize trainer
    trainer = Trainer(model, train_loader, val_loader, criterion, optimizer, device, scheduler)

    # Train model
    print("Starting training...")
    train_losses, val_losses, train_ious, val_ious, train_dices, val_dices = trainer.train(NUM_EPOCHS)

    # Plot training curves
    plot_training_curves(train_losses, val_losses, train_ious, val_ious, train_dices, val_dices)

    # Get fixed test images for visualization
    fixed_test_images, fixed_test_masks = get_fixed_test_images(test_loader, num_images=10)

    # Plot predictions
    save_and_plot_predictions_fixed(model, fixed_test_images, fixed_test_masks, device)

    # Evaluate on test set
    model.eval()
    test_dice = 0.0
    test_iou = 0.0
    num_test_samples = 0

    with torch.no_grad():
        for images, masks in test_loader:
            images, masks = images.to(device), masks.to(device)
            outputs = model(images)
            pred_binary = (outputs > 0.5).float()

            test_dice += dice_coefficient(pred_binary, masks).item() * images.size(0)
            test_iou += iou_score(pred_binary, masks).item() * images.size(0)
            num_test_samples += images.size(0)

    test_dice /= num_test_samples
    test_iou /= num_test_samples

    print(f"Final Test Dice Score: {test_dice:.4f}")
    print(f"Final Test IoU Score: {test_iou:.4f}")

if __name__ == "__main__":
    main()